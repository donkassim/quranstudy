/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// surahSlim.json
var require_surahSlim = __commonJS({
  "surahSlim.json"(exports, module2) {
    module2.exports = [
      {
        index: "001",
        title: "Al-Fatiha",
        titleAr: "\u0627\u0644\u0641\u0627\u062A\u062D\u0629",
        count: 7
      },
      {
        index: "002",
        title: "Al-Baqara",
        titleAr: "\u0627\u0644\u0628\u0642\u0631\u0629",
        count: 286
      },
      {
        index: "003",
        title: "Aal-Imran",
        titleAr: "\u0622\u0644 \u0639\u0645\u0631\u0627\u0646",
        count: 200
      },
      {
        index: "004",
        title: "An-Nisaa'",
        titleAr: "\u0627\u0644\u0646\u0633\u0627\u0621",
        count: 176
      },
      {
        index: "005",
        title: "Al-Ma'ida",
        titleAr: "\u0627\u0644\u0645\u0627\u0626\u062F\u0629",
        count: 120
      },
      {
        index: "006",
        title: "Al-An'am",
        titleAr: "\u0627\u0644\u0623\u0646\u0639\u0627\u0645",
        count: 165
      },
      {
        index: "007",
        title: "Al-A'raf",
        titleAr: "\u0627\u0644\u0623\u0639\u0631\u0627\u0641",
        count: 206
      },
      {
        index: "008",
        title: "Al-Anfal",
        titleAr: "\u0627\u0644\u0623\u0646\u0641\u0627\u0644",
        count: 75
      },
      {
        index: "009",
        title: "Al-Tawba",
        titleAr: "\u0627\u0644\u062A\u0648\u0628\u0629",
        count: 129
      },
      {
        index: "010",
        title: "Yunus",
        titleAr: "\u064A\u0648\u0646\u0633",
        count: 109
      },
      {
        index: "011",
        title: "Hud",
        titleAr: "\u0647\u0648\u062F",
        count: 123
      },
      {
        index: "012",
        title: "Yusuf",
        titleAr: "\u064A\u0648\u0633\u0641",
        count: 111
      },
      {
        index: "013",
        title: "Ar-Ra'd",
        titleAr: "\u0627\u0644\u0631\u0639\u062F",
        count: 43
      },
      {
        index: "014",
        title: "Ibrahim",
        titleAr: "\u0625\u0628\u0631\u0627\u0647\u064A\u0645",
        count: 52
      },
      {
        index: "015",
        title: "Al-Hijr",
        titleAr: "\u0627\u0644\u062D\u062C\u0631",
        count: 99
      },
      {
        index: "016",
        title: "An-Nahl",
        titleAr: "\u0627\u0644\u0646\u062D\u0644",
        count: 128
      },
      {
        index: "017",
        title: "Al-Israa",
        titleAr: "\u0627\u0644\u0625\u0633\u0631\u0627\u0621",
        count: 111
      },
      {
        index: "018",
        title: "Al-Kahf",
        titleAr: "\u0627\u0644\u0643\u0647\u0641",
        count: 110
      },
      {
        index: "019",
        title: "Maryam",
        titleAr: "\u0645\u0631\u064A\u0645",
        count: 98
      },
      {
        index: "020",
        title: "Ta-Ha",
        titleAr: "\u0637\u0647",
        count: 135
      },
      {
        index: "021",
        title: "Al-Anbiya",
        titleAr: "\u0627\u0644\u0623\u0646\u0628\u064A\u0627\u0621",
        count: 112
      },
      {
        index: "022",
        title: "Al-Hajj",
        titleAr: "\u0627\u0644\u062D\u062C",
        count: 78
      },
      {
        index: "023",
        title: "Al-Muminun",
        titleAr: "\u0627\u0644\u0645\u0624\u0645\u0646\u0648\u0646",
        count: 118
      },
      {
        index: "024",
        title: "An-Nur",
        titleAr: "\u0627\u0644\u0646\u0648\u0631",
        count: 64
      },
      {
        index: "025",
        title: "Al-Furqan",
        titleAr: "\u0627\u0644\u0641\u0631\u0642\u0627\u0646",
        count: 77
      },
      {
        index: "026",
        title: "Ash-Shuara",
        titleAr: "\u0627\u0644\u0634\u0639\u0631\u0627\u0621",
        count: 227
      },
      {
        index: "027",
        title: "An-Naml",
        titleAr: "\u0627\u0644\u0646\u0645\u0644",
        count: 93
      },
      {
        index: "028",
        title: "Al-Qasas",
        titleAr: "\u0627\u0644\u0642\u0635\u0635",
        count: 88
      },
      {
        index: "029",
        title: "Al-Ankabut",
        titleAr: "\u0627\u0644\u0639\u0646\u0643\u0628\u0648\u062A",
        count: 69
      },
      {
        index: "030",
        title: "Ar-Rum",
        titleAr: "\u0627\u0644\u0631\u0648\u0645",
        count: 60
      },
      {
        index: "031",
        title: "Luqman",
        titleAr: "\u0644\u0642\u0645\u0627\u0646",
        count: 34
      },
      {
        index: "032",
        title: "As-Sajdah",
        titleAr: "\u0627\u0644\u0633\u062C\u062F\u0629",
        count: 30
      },
      {
        index: "033",
        title: "Al-Ahzab",
        titleAr: "\u0627\u0644\u0623\u062D\u0632\u0627\u0628",
        count: 73
      },
      {
        index: "034",
        title: "Saba",
        titleAr: "\u0633\u0628\u0623",
        count: 54
      },
      {
        index: "035",
        title: "Fatir",
        titleAr: "\u0641\u0627\u0637\u0631",
        count: 45
      },
      {
        index: "036",
        title: "Yasin",
        titleAr: "\u064A\u0633",
        count: 83
      },
      {
        index: "037",
        title: "As-Saffat",
        titleAr: "\u0627\u0644\u0635\u0627\u0641\u0627\u062A",
        count: 182
      },
      {
        index: "038",
        title: "Sad",
        titleAr: "\u0635",
        count: 88
      },
      {
        index: "039",
        title: "Az-Zumar",
        titleAr: "\u0627\u0644\u0632\u0645\u0631",
        count: 75
      },
      {
        index: "040",
        title: "Ghafir",
        titleAr: "\u063A\u0627\u0641\u0631",
        count: 85
      },
      {
        index: "041",
        title: "Fussilat",
        titleAr: "\u0641\u0635\u0644\u062A",
        count: 54
      },
      {
        index: "042",
        title: "Ash-Shura",
        titleAr: "\u0627\u0644\u0634\u0648\u0631\u0649",
        count: 53
      },
      {
        index: "043",
        title: "Az-Zukhruf",
        titleAr: "\u0627\u0644\u0632\u062E\u0631\u0641",
        count: 89
      },
      {
        index: "044",
        title: "Ad-Dukhan",
        titleAr: "\u0627\u0644\u062F\u062E\u0627\u0646",
        count: 59
      },
      {
        index: "045",
        title: "Al-Jathiya",
        titleAr: "\u0627\u0644\u062C\u0627\u062B\u064A\u0629",
        count: 37
      },
      {
        index: "046",
        title: "Al-Ahqaf",
        titleAr: "\u0627\u0644\u0623\u062D\u0642\u0627\u0641",
        count: 35
      },
      {
        index: "047",
        title: "Muhammad",
        titleAr: "\u0645\u062D\u0645\u062F",
        count: 38
      },
      {
        index: "048",
        title: "Al-Fath",
        titleAr: "\u0627\u0644\u0641\u062A\u062D",
        count: 29
      },
      {
        index: "049",
        title: "Al-Hujurat",
        titleAr: "\u0627\u0644\u062D\u062C\u0631\u0627\u062A",
        count: 18
      },
      {
        index: "050",
        title: "Qaf",
        titleAr: "\u0642",
        count: 45
      },
      {
        index: "051",
        title: "Az-Zariyat",
        titleAr: "\u0627\u0644\u0630\u0627\u0631\u064A\u0627\u062A",
        count: 60
      },
      {
        index: "052",
        title: "At-Tur",
        titleAr: "\u0627\u0644\u0637\u0648\u0631",
        count: 49
      },
      {
        index: "053",
        title: "An-Najm",
        titleAr: "\u0627\u0644\u0646\u062C\u0645",
        count: 62
      },
      {
        index: "054",
        title: "Al-Qamar",
        titleAr: "\u0627\u0644\u0642\u0645\u0631",
        count: 55
      },
      {
        index: "055",
        title: "Ar-Rahman",
        titleAr: "\u0627\u0644\u0631\u062D\u0645\u0646",
        count: 78
      },
      {
        index: "056",
        title: "Al-Waqia",
        titleAr: "\u0627\u0644\u0648\u0627\u0642\u0639\u0629",
        count: 96
      },
      {
        index: "057",
        title: "Al-Hadid",
        titleAr: "\u0627\u0644\u062D\u062F\u064A\u062F",
        count: 29
      },
      {
        index: "058",
        title: "Al-Mujadilah",
        titleAr: "\u0627\u0644\u0645\u062C\u0627\u062F\u0644\u0629",
        count: 22
      },
      {
        index: "059",
        title: "Al-Hashr",
        titleAr: "\u0627\u0644\u062D\u0634\u0631",
        count: 24
      },
      {
        index: "060",
        title: "Al-Mumtahinah",
        titleAr: "\u0627\u0644\u0645\u0645\u062A\u062D\u0646\u0629",
        count: 13
      },
      {
        index: "061",
        title: "As-Saff",
        titleAr: "\u0627\u0644\u0635\u0641",
        count: 14
      },
      {
        index: "062",
        title: "Al-Jumu'ah",
        titleAr: "\u0627\u0644\u062C\u0645\u0639\u0629",
        count: 11
      },
      {
        index: "063",
        title: "Al-Munafiqun",
        titleAr: "\u0627\u0644\u0645\u0646\u0627\u0641\u0642\u0648\u0646",
        count: 11
      },
      {
        index: "064",
        title: "At-Taghabun",
        titleAr: "\u0627\u0644\u062A\u063A\u0627\u0628\u0646",
        count: 18
      },
      {
        index: "065",
        title: "At-Talaq",
        titleAr: "\u0627\u0644\u0637\u0644\u0627\u0642",
        count: 12
      },
      {
        index: "066",
        title: "At-Tahrim",
        titleAr: "\u0627\u0644\u062A\u062D\u0631\u064A\u0645",
        count: 12
      },
      {
        index: "067",
        title: "Al-Mulk",
        titleAr: "\u0627\u0644\u0645\u0644\u0643",
        count: 30
      },
      {
        index: "068",
        title: "Al-Qalam",
        titleAr: "\u0627\u0644\u0642\u0644\u0645",
        count: 52
      },
      {
        index: "069",
        title: "Al-Haqqah",
        titleAr: "\u0627\u0644\u062D\u0627\u0642\u0629",
        count: 52
      },
      {
        index: "070",
        title: "Al-Ma'arij",
        titleAr: "\u0627\u0644\u0645\u0639\u0627\u0631\u062C",
        count: 44
      },
      {
        index: "071",
        title: "Nuh",
        titleAr: "\u0646\u0648\u062D",
        count: 28
      },
      {
        index: "072",
        title: "Al-Jinn",
        titleAr: "\u0627\u0644\u062C\u0646",
        count: 28
      },
      {
        index: "073",
        title: "Al-Muzzammil",
        titleAr: "\u0627\u0644\u0645\u0632\u0645\u0644",
        count: 20
      },
      {
        index: "074",
        title: "Al-Muddaththir",
        titleAr: "\u0627\u0644\u0645\u062F\u062B\u0631",
        count: 56
      },
      {
        index: "075",
        title: "Al-Qiyamah",
        titleAr: "\u0627\u0644\u0642\u064A\u0627\u0645\u0629",
        count: 40
      },
      {
        index: "076",
        title: "Al-Insan",
        titleAr: "\u0627\u0644\u0625\u0646\u0633\u0627\u0646",
        count: 31
      },
      {
        index: "077",
        title: "Al-Mursalat",
        titleAr: "\u0627\u0644\u0645\u0631\u0633\u0644\u0627\u062A",
        count: 50
      },
      {
        index: "078",
        title: "An-Naba",
        titleAr: "\u0627\u0644\u0646\u0628\u0623",
        count: 40
      },
      {
        index: "079",
        title: "An-Naziat",
        titleAr: "\u0627\u0644\u0646\u0627\u0632\u0639\u0627\u062A",
        count: 46
      },
      {
        index: "080",
        title: "Abasa",
        titleAr: "\u0639\u0628\u0633",
        count: 42
      },
      {
        index: "081",
        title: "At-Takwir",
        titleAr: "\u0627\u0644\u062A\u0643\u0648\u064A\u0631",
        count: 29
      },
      {
        index: "082",
        title: "Al-Infitar",
        titleAr: "\u0627\u0644\u0625\u0646\u0641\u0637\u0627\u0631",
        count: 19
      },
      {
        index: "083",
        title: "Al-Mutaffifin",
        titleAr: "\u0627\u0644\u0645\u0637\u0641\u0641\u064A\u0646",
        count: 36
      },
      {
        index: "084",
        title: "Al-Inshiqaq",
        titleAr: "\u0627\u0644\u0625\u0646\u0634\u0642\u0627\u0642",
        count: 25
      },
      {
        index: "085",
        title: "Al-Buruj",
        titleAr: "\u0627\u0644\u0628\u0631\u0648\u062C",
        count: 22
      },
      {
        index: "086",
        title: "At-Tariq",
        titleAr: "\u0627\u0644\u0637\u0627\u0631\u0642",
        count: 17
      },
      {
        index: "087",
        title: "Al-Ala",
        titleAr: "\u0627\u0644\u0623\u0639\u0644\u0649",
        count: 19
      },
      {
        index: "088",
        title: "Al-Ghashiyah",
        titleAr: "\u0627\u0644\u063A\u0627\u0634\u064A\u0629",
        count: 26
      },
      {
        index: "089",
        title: "Al-Fajr",
        titleAr: "\u0627\u0644\u0641\u062C\u0631",
        count: 30
      },
      {
        index: "090",
        title: "Al-Balad",
        titleAr: "\u0627\u0644\u0628\u0644\u062F",
        count: 20
      },
      {
        index: "091",
        title: "Ash-Shams",
        titleAr: "\u0627\u0644\u0634\u0645\u0633",
        count: 15
      },
      {
        index: "092",
        title: "Al-Lail",
        titleAr: "\u0627\u0644\u0644\u064A\u0644",
        count: 21
      },
      {
        index: "093",
        title: "Ad-Duha",
        titleAr: "\u0627\u0644\u0636\u062D\u0649",
        count: 11
      },
      {
        index: "094",
        title: "Ash-Sharh",
        titleAr: "\u0627\u0644\u0634\u0631\u062D",
        count: 8
      },
      {
        index: "095",
        title: "At-Tin",
        titleAr: "\u0627\u0644\u062A\u064A\u0646",
        count: 8
      },
      {
        index: "096",
        title: "Al-Alaq",
        titleAr: "\u0627\u0644\u0639\u0644\u0642",
        count: 19
      },
      {
        index: "097",
        title: "Al-Qadr",
        titleAr: "\u0627\u0644\u0642\u062F\u0631",
        count: 5
      },
      {
        index: "098",
        title: "Al-Bayinah",
        titleAr: "\u0627\u0644\u0628\u064A\u0646\u0629",
        count: 8
      },
      {
        index: "099",
        title: "Az-Zalzalah",
        titleAr: "\u0627\u0644\u0632\u0644\u0632\u0644\u0629",
        count: 8
      },
      {
        index: "100",
        title: "Al-Adiyat",
        titleAr: "\u0627\u0644\u0639\u0627\u062F\u064A\u0627\u062A",
        count: 11
      },
      {
        index: "101",
        title: "Al-Qariah",
        titleAr: "\u0627\u0644\u0642\u0627\u0631\u0639\u0629",
        count: 11
      },
      {
        index: "102",
        title: "Al-Takathur",
        titleAr: "\u0627\u0644\u062A\u0643\u0627\u062B\u0631",
        count: 8
      },
      {
        index: "103",
        title: "Al-Asr",
        titleAr: "\u0627\u0644\u0639\u0635\u0631",
        count: 3
      },
      {
        index: "104",
        title: "Al-Humazah",
        titleAr: "\u0627\u0644\u0647\u0645\u0632\u0629",
        count: 9
      },
      {
        index: "105",
        title: "Al-Fil",
        titleAr: "\u0627\u0644\u0641\u064A\u0644",
        count: 5
      },
      {
        index: "106",
        title: "Quraish",
        titleAr: "\u0642\u0631\u064A\u0634",
        count: 4
      },
      {
        index: "107",
        title: "Al-Ma'un",
        titleAr: "\u0627\u0644\u0645\u0627\u0639\u0648\u0646",
        count: 7
      },
      {
        index: "108",
        title: "Al-Kauthar",
        titleAr: "\u0627\u0644\u0643\u0648\u062B\u0631",
        count: 3
      },
      {
        index: "109",
        title: "Al-Kafirun",
        titleAr: "\u0627\u0644\u0643\u0627\u0641\u0631\u0648\u0646",
        count: 6
      },
      {
        index: "110",
        title: "An-Nasr",
        titleAr: "\u0627\u0644\u0646\u0635\u0631",
        count: 3
      },
      {
        index: "111",
        title: "Al-Masad",
        titleAr: "\u0627\u0644\u0645\u0633\u062F",
        count: 5
      },
      {
        index: "112",
        title: "Al-Ikhlas",
        titleAr: "\u0627\u0644\u0625\u062E\u0644\u0627\u0635",
        count: 4
      },
      {
        index: "113",
        title: "Al-Falaq",
        titleAr: "\u0627\u0644\u0641\u0644\u0642",
        count: 5
      },
      {
        index: "114",
        title: "An-Nas",
        titleAr: "\u0627\u0644\u0646\u0627\u0633",
        count: 6
      }
    ];
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuranLookupPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max) => `Pattern length exceeds max of ${max}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
var BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
var AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start === -1) {
      start = i;
    } else if (!match && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text = text.toLowerCase();
    }
    if (this.pattern === text) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text) {
    const isMatch = text === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text) {
    const index = text.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text) {
    const isMatch = text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text) {
    const isMatch = !text.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text) {
    const isMatch = text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text.length - this.pattern.length, text.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text) {
    const isMatch = !text.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text) {
    return this._bitapSearch.searchIn(text);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text = isCaseSensitive ? text : text.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text, i: idx, n: norm2 }) => {
      if (!isDefined(text)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        results.push({
          item: text,
          idx,
          matches: [{ score, value: text, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(...this._findMatches({
          key,
          value: item[keyIndex],
          searcher
        }));
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text);
      if (isMatch) {
        matches.push({ score, key, value: text, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// DraggableKeyboard.ts
var DraggableKeyboard = class {
  constructor(container, onKeyPress) {
    this.isDragging = false;
    this.xOffset = 0;
    this.yOffset = 0;
    this.container = container;
    this.onKeyPress = onKeyPress;
    const header = document.createElement("div");
    header.classList.add("draggable-header");
    header.style.display = "flex";
    header.style.justifyContent = "space-between";
    header.style.alignItems = "center";
    header.style.padding = "5px 10px";
    header.style.backgroundColor = "var(--background-secondary)";
    header.style.cursor = "move";
    header.style.borderBottom = "1px solid var(--background-modifier-border)";
    const title = document.createElement("span");
    title.textContent = "Arabic Keyboard";
    title.style.flexGrow = "1";
    title.style.color = "var(--text-primary)";
    title.style.fontWeight = "bold";
    const closeButton = document.createElement("button");
    closeButton.classList.add("search-input-clear-button");
    closeButton.style.position = "relative";
    closeButton.style.border = "none";
    closeButton.style.cursor = "pointer";
    closeButton.addEventListener("click", () => {
      this.hide();
    });
    header.appendChild(title);
    header.appendChild(closeButton);
    this.container.appendChild(header);
    this.setupDraggable(header);
    this.setupStyles();
  }
  setupStyles() {
    this.container.style.position = "fixed";
    this.container.style.backgroundColor = "var(--background-primary)";
    this.container.style.border = "1px solid var(--background-modifier-border)";
    this.container.style.borderRadius = "6px";
    this.container.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.15)";
    this.container.style.zIndex = "1000";
    this.container.style.cursor = "move";
    this.container.style.userSelect = "none";
    this.container.style.width = "90%";
    this.container.style.maxWidth = "600px";
    this.container.style.left = "50%";
    this.container.style.transform = "translateX(-50%)";
    this.container.classList.add("draggable-keyboard-container");
  }
  setupDraggable(draggableElement) {
    this.container.addEventListener("mousedown", this.dragStart.bind(this));
    document.addEventListener("mousemove", this.drag.bind(this));
    document.addEventListener("mouseup", this.dragEnd.bind(this));
    this.container.addEventListener("touchstart", this.dragStart.bind(this), { passive: false });
    document.addEventListener("touchmove", this.drag.bind(this), { passive: false });
    document.addEventListener("touchend", this.dragEnd.bind(this));
  }
  dragStart(e) {
    if (e.target.tagName === "BUTTON") {
      return;
    }
    if (e instanceof TouchEvent) {
      const touch = e.touches[0];
      this.initialX = touch.clientX - this.xOffset;
      this.initialY = touch.clientY - this.yOffset;
    } else {
      this.initialX = e.clientX - this.xOffset;
      this.initialY = e.clientY - this.yOffset;
    }
    this.isDragging = true;
  }
  drag(e) {
    if (!this.isDragging)
      return;
    e.preventDefault();
    if (e instanceof TouchEvent) {
      const touch = e.touches[0];
      this.currentX = touch.clientX - this.initialX;
      this.currentY = touch.clientY - this.initialY;
    } else {
      this.currentX = e.clientX - this.initialX;
      this.currentY = e.clientY - this.initialY;
    }
    this.xOffset = this.currentX;
    this.yOffset = this.currentY;
    this.setTranslate(this.currentX, this.currentY);
  }
  dragEnd() {
    this.initialX = this.currentX;
    this.initialY = this.currentY;
    this.isDragging = false;
  }
  setTranslate(xPos, yPos) {
    this.container.style.transform = `translate(${xPos}px, ${yPos}px)`;
  }
  createKeyboard(arabicKeys, isShiftPressed = false) {
    let keyboardSection = this.container.querySelector(".keyboard-section");
    if (!keyboardSection) {
      keyboardSection = document.createElement("div");
      keyboardSection.classList.add("keyboard-section");
      this.container.appendChild(keyboardSection);
    }
    keyboardSection.innerHTML = "";
    const rows = isShiftPressed ? ["shiftRow2", "shiftRow3", "shiftRow4"] : ["row2", "row3", "row4"];
    rows.forEach((rowKey) => {
      const keyboardRow = document.createElement("div");
      keyboardRow.style.display = "flex";
      keyboardRow.style.justifyContent = "center";
      keyboardRow.style.gap = "4px";
      keyboardRow.style.marginBottom = "4px";
      if (rowKey === "row4" || rowKey === "shiftRow4") {
        const leftShiftKey = document.createElement("button");
        leftShiftKey.style.minWidth = "80px";
        leftShiftKey.style.height = "36px";
        leftShiftKey.style.padding = "8px";
        leftShiftKey.style.border = "1px solid var(--background-modifier-border)";
        leftShiftKey.style.borderRadius = "4px";
        leftShiftKey.style.backgroundColor = isShiftPressed ? "var(--background-modifier-hover)" : "var(--background-primary)";
        leftShiftKey.style.cursor = "pointer";
        leftShiftKey.textContent = "Shift";
        leftShiftKey.addEventListener("click", (e) => {
          e.stopPropagation();
          this.createKeyboard(arabicKeys, !isShiftPressed);
        });
        keyboardRow.appendChild(leftShiftKey);
      }
      arabicKeys[rowKey].forEach((key) => {
        const keyButton = document.createElement("button");
        keyButton.classList.add("quran-arabic");
        keyButton.style.minWidth = "36px";
        keyButton.style.height = "36px";
        keyButton.style.padding = "8px";
        keyButton.style.border = "1px solid var(--background-modifier-border)";
        keyButton.style.borderRadius = "4px";
        keyButton.style.backgroundColor = "var(--background-primary)";
        keyButton.style.cursor = "pointer";
        keyButton.textContent = key;
        keyButton.addEventListener("click", (e) => {
          e.stopPropagation();
          this.onKeyPress(key);
        });
        keyboardRow.appendChild(keyButton);
      });
      if (rowKey === "row2" || rowKey === "shiftRow2") {
        const backspaceKey = document.createElement("button");
        backspaceKey.style.minWidth = "36px";
        backspaceKey.style.height = "36px";
        backspaceKey.style.padding = "8px";
        backspaceKey.style.border = "1px solid var(--background-modifier-border)";
        backspaceKey.style.borderRadius = "4px";
        backspaceKey.style.backgroundColor = "var(--background-primary)";
        backspaceKey.style.cursor = "pointer";
        backspaceKey.textContent = "\u232B";
        backspaceKey.addEventListener("click", (e) => {
          e.stopPropagation();
          this.onKeyPress("Backspace");
        });
        keyboardRow.appendChild(backspaceKey);
      }
      if (rowKey === "row4" || rowKey === "shiftRow4") {
        const rightShiftKey = document.createElement("button");
        rightShiftKey.style.minWidth = "80px";
        rightShiftKey.style.height = "36px";
        rightShiftKey.style.padding = "8px";
        rightShiftKey.style.border = "1px solid var(--background-modifier-border)";
        rightShiftKey.style.borderRadius = "4px";
        rightShiftKey.style.backgroundColor = isShiftPressed ? "var(--background-modifier-hover)" : "var(--background-primary)";
        rightShiftKey.style.cursor = "pointer";
        rightShiftKey.textContent = "Shift";
        rightShiftKey.addEventListener("click", (e) => {
          e.stopPropagation();
          this.createKeyboard(arabicKeys, !isShiftPressed);
        });
        keyboardRow.appendChild(rightShiftKey);
      }
      keyboardSection.appendChild(keyboardRow);
    });
    const spacebarRow = document.createElement("div");
    spacebarRow.style.display = "flex";
    spacebarRow.style.justifyContent = "center";
    spacebarRow.style.marginTop = "4px";
    const spacebar = document.createElement("button");
    spacebar.style.flexGrow = "0.5";
    spacebar.style.minHeight = "36px";
    spacebar.style.padding = "8px";
    spacebar.style.border = "1px solid var(--background-modifier-border)";
    spacebar.style.borderRadius = "4px";
    spacebar.style.backgroundColor = "var(--background-primary)";
    spacebar.style.cursor = "pointer";
    spacebar.textContent = "Space";
    spacebar.addEventListener("click", (e) => {
      e.stopPropagation();
      this.onKeyPress(" ");
    });
    spacebarRow.appendChild(spacebar);
    keyboardSection.appendChild(spacebarRow);
  }
  show() {
    this.container.style.display = "block";
  }
  hide() {
    this.container.style.display = "none";
  }
  destroy() {
    document.removeEventListener("mousemove", this.drag.bind(this));
    document.removeEventListener("mouseup", this.dragEnd.bind(this));
  }
};

// main.ts
var Translations = {
  en: [
    { identifier: "en.ahmedali", name: "Ahmed Ali" },
    { identifier: "en.ahmedraza", name: "Ahmed Raza Khan" },
    { identifier: "en.arberry", name: "Arberry" },
    { identifier: "en.asad", name: "Asad" },
    { identifier: "en.daryabadi", name: "Daryabadi" },
    { identifier: "en.hilali", name: "Hilali & Khan" },
    { identifier: "en.pickthall", name: "Pickthall" },
    { identifier: "en.qaribullah", name: "Qaribullah & Darwish" },
    { identifier: "en.sahih", name: "Saheeh International" },
    { identifier: "en.sarwar", name: "Sarwar" },
    { identifier: "en.yusufali", name: "Yusuf Ali" },
    { identifier: "en.maududi", name: "Maududi" },
    { identifier: "en.shakir", name: "Shakir" },
    { identifier: "en.transliteration", name: "Transliteration" },
    { identifier: "en.walk", name: "Ibrahim Walk" },
    { identifier: "en.itani", name: "Clear Qur'an - Talal Itani" },
    { identifier: "en.mubarakpuri", name: "Mubarakpuri" },
    { identifier: "en.qarai", name: "Qarai" },
    { identifier: "en.wahiduddin", name: "Wahiduddin Khan" }
  ],
  fr: [{ identifier: "fr.hamidullah", name: "Hamidullah" }],
  de: [
    { identifier: "de.aburida", name: "Abu Rida" },
    { identifier: "de.bubenheim", name: "Bubenheim & Elyas" }
  ],
  az: [
    { identifier: "az.mammadaliyev", name: "M\u0259mm\u0259d\u0259liyev & B\xFCnyadov" },
    { identifier: "az.musayev", name: "Musayev" }
  ],
  bn: [{ identifier: "bn.bengali", name: "Muhiuddin Khan" }],
  cs: [
    { identifier: "cs.hrbek", name: "Hrbek" },
    { identifier: "cs.nykl", name: "Nykl" }
  ],
  dv: [
    { identifier: "dv.divehi", name: "Office of the President of Maldives" }
  ],
  fa: [
    { identifier: "fa.ayati", name: "Ayati" },
    { identifier: "fa.fooladvand", name: "Fooladvand" },
    { identifier: "fa.ghomshei", name: "Elahi Ghomshei" }
  ],
  ha: [{ identifier: "ha.gumi", name: "Gumi" }],
  hi: [
    {
      identifier: "hi.hindi",
      name: "Suhel Farooq Khan and Saifur Rahman Nadwi"
    }
  ],
  id: [{ identifier: "id.indonesian", name: "Bahasa Indonesia" }],
  it: [{ identifier: "it.piccardo", name: "Piccardo" }],
  ja: [{ identifier: "ja.japanese", name: "Japanese" }],
  ko: [{ identifier: "ko.korean", name: "Korean" }],
  ku: [{ identifier: "ku.asan", name: "Burhan Muhammad-Amin" }],
  ml: [
    {
      identifier: "ml.abdulhameed",
      name: "Cheriyamundam Abdul Hameed and Kunhi Mohammed Parappoor"
    }
  ],
  nl: [{ identifier: "nl.keyzer", name: "Keyzer" }],
  no: [{ identifier: "no.berg", name: "Einar Berg" }],
  pl: [{ identifier: "pl.bielawskiego", name: "Bielawskiego" }],
  pt: [{ identifier: "pt.elhayek", name: "El-Hayek" }],
  ro: [{ identifier: "ro.grigore", name: "Grigore" }],
  ru: [
    { identifier: "ru.kuliev", name: "Kuliev" },
    { identifier: "ru.osmanov", name: "Osmanov" },
    { identifier: "ru.porokhova", name: "Porokhova" }
  ],
  sd: [{ identifier: "sd.amroti", name: "Amroti" }],
  so: [{ identifier: "so.abduh", name: "Abduh" }],
  sq: [
    { identifier: "sq.ahmeti", name: "Sherif Ahmeti" },
    { identifier: "sq.mehdiu", name: "Feti Mehdiu" },
    { identifier: "sq.nahi", name: "Efendi Nahi" }
  ],
  sv: [{ identifier: "sv.bernstrom", name: "Bernstr\xF6m" }],
  sw: [{ identifier: "sw.barwani", name: "Al-Barwani" }],
  ta: [{ identifier: "ta.tamil", name: "Jan Turst Foundation" }],
  th: [{ identifier: "th.thai", name: "King Fahad Quran Complex" }],
  tr: [
    { identifier: "tr.ates", name: "Suleyman Ates" },
    { identifier: "tr.bulac", name: "Ali Bula\xE7" },
    { identifier: "tr.diyanet", name: "Diyanet \u0130\u015Fleri" }
  ],
  tt: [{ identifier: "tt.nugman", name: "Yakub Ibn Nugman" }],
  ug: [{ identifier: "ug.saleh", name: "Muhammad Saleh" }],
  ur: [
    { identifier: "ur.ahmedali", name: "Ahmed Ali" },
    { identifier: "ur.jalandhry", name: "Fateh Muhammad Jalandhry" },
    { identifier: "ur.jawadi", name: "Syed Zeeshan Haider Jawadi" }
  ],
  uz: [{ identifier: "uz.sodik", name: "Muhammad Sodik Muhammad Yusuf" }]
};
var DisplayOptions = {
  0: "Text Only",
  1: "Markdown Table",
  2: "Obsidian Callout (original)"
};
var ArabicStyleOptions = {
  0: "None",
  1: "HTML span w/ class",
  2: "Code Override (`)"
};
var DEFAULT_SETTINGS = {
  translatorLanguage: "en",
  translatorIndex: 0,
  displayTypeIndex: 2,
  arabicStyleIndex: 0,
  includeTranslation: true,
  removeParens: true,
  displayTable: false,
  displayCallOut: true,
  calloutType: "tip",
  wrapQuranInCode: false,
  wrapQuranInSpan: false,
  fontFamily: "me_quran",
  fontSize: "24px",
  offlineMode: false,
  searchArabicEdition: false
};
var QuranSearchModal = class extends import_obsidian.SuggestModal {
  constructor(app, plugin, editor) {
    super(app);
    this.searchResults = [];
    this.suggestions = [];
    this.currentPage = 1;
    this.resultsPerPage = 10;
    this.totalPages = 1;
    this.fetchedArabicVerses = /* @__PURE__ */ new Set();
    this.fetchedTranslationVerses = /* @__PURE__ */ new Set();
    this.plugin = plugin;
    this.editor = editor;
    this.setPlaceholder("Enter text to search for in the Quran or Translation...");
    const footerEl = this.modalEl.createDiv({ cls: "search-results-footer" });
    const controlsContainer = this.modalEl.createDiv({ cls: "search-controls-container" });
    const checkboxContainer = controlsContainer.createDiv({ cls: "search-arabic-container" });
    const keyboardContainer = this.modalEl.createDiv();
    keyboardContainer.style.position = "absolute";
    keyboardContainer.style.backgroundColor = "var(--background-primary)";
    keyboardContainer.style.border = "1px solid var(--background-modifier-border)";
    keyboardContainer.style.borderRadius = "6px";
    keyboardContainer.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.15)";
    keyboardContainer.style.zIndex = "1000";
    keyboardContainer.style.left = "50%";
    keyboardContainer.style.transform = "translateX(-50%)";
    keyboardContainer.style.width = "90%";
    keyboardContainer.style.maxWidth = "600px";
    keyboardContainer.style.display = "none";
    this.keyboard = new DraggableKeyboard(keyboardContainer, (key) => {
      var _a, _b;
      const textarea = this.inputEl;
      const start = (_a = textarea.selectionStart) != null ? _a : textarea.value.length;
      const end = (_b = textarea.selectionEnd) != null ? _b : textarea.value.length;
      const content = textarea.value;
      if (key === "Backspace") {
        if (start > 0) {
          textarea.value = content.substring(0, start - 1) + content.substring(end);
          textarea.selectionStart = textarea.selectionEnd = start - 1;
        }
      } else {
        textarea.value = content.substring(0, start) + key + content.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + key.length;
      }
      textarea.focus();
    });
    const paginationControlsEl = footerEl.createDiv({ cls: "pagination-controls" });
    this.paginationEl = paginationControlsEl.createDiv("search-pagination");
    this.paginationEl.style.display = "flex";
    this.paginationEl.style.justifyContent = "center";
    this.paginationEl.style.gap = "10px";
    this.paginationEl.style.marginTop = "10px";
    this.paginationEl.style.width = "100%";
    const prevButton = this.paginationEl.createEl("button", { text: "Previous" });
    const pageInfo = this.paginationEl.createSpan();
    const nextButton = this.paginationEl.createEl("button", { text: "Next" });
    prevButton.onclick = () => this.changePage(this.currentPage - 1);
    nextButton.onclick = () => this.changePage(this.currentPage + 1);
    const paginationInfo = footerEl.createSpan({ cls: "pagination-info" });
    this.updatePaginationInfo(pageInfo, prevButton, nextButton);
  }
  onOpen() {
    super.onOpen();
    const { contentEl } = this;
    const headerEl = contentEl.createDiv({ cls: "search-results-header" });
    const countEl = headerEl.createSpan({ cls: "search-results-count" });
    this.updateSearchCount(countEl);
    const resultsContainer = contentEl.createDiv();
    resultsContainer.style.margin = "8px";
    setTimeout(() => {
      const resultsContainer2 = this.modalEl.querySelector(".prompt-results");
      if (!resultsContainer2) {
        console.error("Results container not found");
        return;
      }
      const controlsContainer = createEl("div", { cls: "search-controls-container" });
      resultsContainer2.insertAdjacentElement("beforebegin", controlsContainer);
      const checkboxContainer = createEl("div", { cls: "search-arabic-container" });
      controlsContainer.appendChild(checkboxContainer);
      this.searchArabicCheckbox = checkboxContainer.createEl("input", { type: "checkbox" });
      this.searchArabicCheckbox.checked = this.plugin.settings.searchArabicEdition;
      const label = checkboxContainer.createEl("label");
      label.textContent = "Search Arabic Quran";
      const keyboardButton = checkboxContainer.createEl("button", { cls: "keyboard-button", text: "" });
      keyboardButton.textContent = "ar \u2328";
      let keyboardVisible = false;
      keyboardButton.addEventListener("click", () => {
        keyboardVisible = !keyboardVisible;
        if (keyboardVisible) {
          this.keyboard.show();
          this.keyboard.createKeyboard({
            row2: ["\u0636", "\u0635", "\u062B", "\u0642", "\u0641", "\u063A", "\u0639", "\u0647", "\u062E", "\u062D", "\u062C", "\u062F", "\\"],
            row3: ["\u0634", "\u0633", "\u064A", "\u0628", "\u0644", "\u0627", "\u062A", "\u0646", "\u0645", "\u0643", "\u0637"],
            row4: ["\u0626", "\u0621", "\u0624", "\u0631", "\u0644\u0627", "\u0649", "\u0629", "\u0648", "\u0632", "\u0638"],
            shiftRow2: ["\u064E", "\u064B", "\u064F", "\u064C", "\u0644\u0625", "\u0625", "'", "\xF7", "\xD7", "\u061B", "<", ">", "|"],
            shiftRow3: ["\u0650", "\u064D", "]", "[", "\u0644\u0623", "\u0623", "\u0640", "\u060C", "/", ":"],
            shiftRow4: ["~", "\u0652", "{", "}", "\u0644\u0622", "\u0622", "\u0651", ",", ".", "\u0630"]
          });
          this.inputEl.focus();
        } else {
          this.keyboard.hide();
        }
      });
      const searchButton = createEl("button", {
        cls: "mod-cta",
        text: "Search"
      });
      controlsContainer.appendChild(searchButton);
      this.searchArabicCheckbox.addEventListener("change", (e) => {
        this.plugin.settings.searchArabicEdition = this.searchArabicCheckbox.checked;
        this.plugin.saveSettings();
      });
      searchButton.addEventListener("click", async () => {
        await this.performSearch();
      });
      this.inputEl.addEventListener("keydown", async (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          await this.performSearch();
        }
      });
    }, 50);
  }
  onClose() {
    if (this.keyboard) {
      this.keyboard.destroy();
    }
  }
  updateSearchCount(countEl) {
    const count = this.searchResults.length;
    countEl.setText(`${count} Search Results`);
  }
  updatePaginationDisplay() {
    const pageInfo = this.paginationEl.querySelector("span");
    const buttons = Array.from(this.paginationEl.querySelectorAll("button"));
    const [prevButton, nextButton] = buttons;
    if (pageInfo && prevButton && nextButton) {
      this.updatePaginationInfo(pageInfo, prevButton, nextButton);
      this.refreshSuggestions();
    }
  }
  updatePaginationInfo(pageInfo, prevButton, nextButton) {
    const totalResults = this.searchResults.length;
    this.totalPages = Math.ceil(totalResults / this.resultsPerPage);
    pageInfo.setText(`Page ${this.currentPage} of ${this.totalPages}`);
    const footerEl = this.modalEl.querySelector(".search-results-footer");
    if (footerEl) {
      const paginationInfo = footerEl.querySelector(".pagination-info");
      if (paginationInfo) {
        const start = (this.currentPage - 1) * this.resultsPerPage + 1;
        const end = Math.min(this.currentPage * this.resultsPerPage, totalResults);
        paginationInfo.setText(`${start}-${end} of ${totalResults} Search Results`);
      }
    }
    prevButton.disabled = this.currentPage === 1;
    nextButton.disabled = this.currentPage === this.totalPages || this.totalPages === 0;
  }
  changePage(newPage) {
    if (newPage >= 1 && newPage <= this.totalPages) {
      this.currentPage = newPage;
      this.updatePaginationDisplay();
      if (!this.plugin.settings.searchArabicEdition) {
        this.fetchArabicVersesForCurrentPage();
      } else {
        this.fetchTranslationVersesForCurrentPage();
      }
    }
  }
  async performArabicOfflineSearch(query) {
    var _a;
    if (!((_a = this.plugin.offlineData) == null ? void 0 : _a["ar.quran-simple"])) {
      throw new Error("Arabic offline data not available");
    }
    return await this.plugin.searchOfflineArabic(query);
  }
  async performTranslationOfflineSearch(query) {
    const edition = Translations[this.plugin.settings.translatorLanguage][this.plugin.settings.translatorIndex].identifier;
    const offlineData = this.plugin.offlineData[edition];
    if (!offlineData) {
      throw new Error(`No offline data available for edition: ${edition}`);
    }
    return this.plugin.searchOfflineTranslation(query);
  }
  async performSearch() {
    var _a, _b, _c;
    const query = this.inputEl.value;
    if (query.length < 3) {
      new import_obsidian.Notice("Please enter at least 3 characters to search");
      return;
    }
    try {
      new import_obsidian.Notice("Searching...");
      this.fetchedArabicVerses.clear();
      this.fetchedTranslationVerses.clear();
      let translationResults = [];
      if (this.plugin.settings.searchArabicEdition) {
        if (!((_a = this.plugin.offlineData) == null ? void 0 : _a["ar.quran-simple"])) {
          new import_obsidian.Notice("Offline Arabic data not available... attempting to download");
          try {
            await this.plugin.loadFromOfflineStorage("ar.quran-simple");
            if (!((_b = this.plugin.offlineData) == null ? void 0 : _b["ar.quran-simple"])) {
              new import_obsidian.Notice("Failed to download Arabic offline data");
              return;
            }
          } catch (error) {
            console.error("Error downloading Arabic offline data:", error);
            new import_obsidian.Notice("Error downloading Arabic offline data");
            return;
          }
        }
        console.log("Performing offline Arabic search...");
        try {
          translationResults = await this.performArabicOfflineSearch(query);
        } catch (error) {
          console.error("Error in offline Arabic search:", error);
          new import_obsidian.Notice("Error performing offline Arabic search");
          return;
        }
      } else {
        const edition = this.plugin.settings.searchArabicEdition ? "ar.quran-simple" : Translations[this.plugin.settings.translatorLanguage][this.plugin.settings.translatorIndex].identifier;
        const hasOfflineData = (_c = this.plugin.offlineData) == null ? void 0 : _c[edition];
        if (hasOfflineData) {
          try {
            console.log("Performing offline translation search...");
            translationResults = await this.performTranslationOfflineSearch(query);
          } catch (error) {
            console.error("Error in offline translation search, falling back to online:", error);
            console.log("Fallback: API Performing online translation search...");
            const results = await Promise.all([
              fetch(`http://api.alquran.cloud/v1/search/${encodeURIComponent(query)}/all/${edition}`).then((res) => res.json()).catch((error2) => ({ code: 500, error: error2.message }))
            ]);
            translationResults = results[0].code === 200 ? results[0].data.matches : [];
          }
        } else {
          console.log("API Performing online translation search...");
          const results = await Promise.all([
            fetch(`http://api.alquran.cloud/v1/search/${encodeURIComponent(query)}/all/${edition}`).then((res) => res.json()).catch((error) => ({ code: 500, error: error.message }))
          ]);
          translationResults = results[0].code === 200 ? results[0].data.matches : [];
        }
      }
      if (translationResults.length === 0) {
        new import_obsidian.Notice("No matches found");
        this.searchResults = [];
        this.updatePaginationDisplay();
        return;
      }
      this.searchResults = translationResults;
      this.currentPage = 1;
      this.totalPages = Math.ceil(this.searchResults.length / this.resultsPerPage);
      if (!this.plugin.settings.searchArabicEdition) {
        await this.fetchArabicVersesForCurrentPage();
      } else {
        await this.fetchTranslationVersesForCurrentPage();
      }
      this.updatePaginationDisplay();
      new import_obsidian.Notice(`Found ${this.searchResults.length} matches`);
    } catch (error) {
      new import_obsidian.Notice("Error searching Quran: " + error.message);
      console.error("Search error:", error);
    }
    this.refreshSuggestions();
  }
  async fetchArabicVersesForCurrentPage() {
    var _a;
    if (this.plugin.settings.searchArabicEdition) {
      return;
    }
    try {
      const startIdx = (this.currentPage - 1) * this.resultsPerPage;
      const endIdx = Math.min(startIdx + this.resultsPerPage, this.searchResults.length);
      const currentPageResults = this.searchResults.slice(startIdx, endIdx);
      const unfetchedResults = currentPageResults.filter((match) => {
        const verseKey = `${match.surah.number}:${match.numberInSurah}`;
        return !this.fetchedArabicVerses.has(verseKey) && !match.arabicText;
      });
      if (unfetchedResults.length === 0) {
        return;
      }
      const offlineMode = this.plugin.settings.offlineMode && ((_a = this.plugin.offlineData) == null ? void 0 : _a["ar.quran-simple"]);
      if (offlineMode) {
        console.log("Offline mode enabled. Fetching Arabic verses for current page from local data...");
        unfetchedResults.forEach((match) => {
          var _a2, _b, _c, _d, _e, _f;
          const verseKey = `${match.surah.number}:${match.numberInSurah}`;
          const localVerse = (_f = (_e = (_d = (_c = (_b = (_a2 = this.plugin.offlineData) == null ? void 0 : _a2["ar.quran-simple"]) == null ? void 0 : _b.data) == null ? void 0 : _c.surahs) == null ? void 0 : _d[match.surah.number - 1]) == null ? void 0 : _e.ayahs) == null ? void 0 : _f.find((verse) => verse.numberInSurah === match.numberInSurah);
          if (localVerse == null ? void 0 : localVerse.text) {
            match.arabicText = localVerse.text;
            this.fetchedArabicVerses.add(verseKey);
          }
        });
        this.refreshSuggestions();
        return;
      }
      console.log("Online mode enabled. Fetching Arabic verses for current page by API...");
      const fetchPromises = unfetchedResults.map((match) => () => {
        const verseKey = `${match.surah.number}:${match.numberInSurah}`;
        return fetch(`http://api.alquran.cloud/v1/ayah/${match.surah.number}:${match.numberInSurah}/ar.quran-simple`).then((res) => res.json()).then((data) => ({ match, data, verseKey })).catch((error) => ({ match, error, verseKey }));
      });
      const results = await rateLimit(fetchPromises, 3, 1e3);
      results.forEach((result) => {
        var _a2;
        if (((_a2 = result.data) == null ? void 0 : _a2.code) === 200) {
          result.match.arabicText = result.data.data.text;
          this.fetchedArabicVerses.add(result.verseKey);
        } else if (result.error) {
          console.error(`Error fetching Arabic verse for ${result.match.surah.number}:${result.match.numberInSurah}:`, result.error);
        }
      });
      this.refreshSuggestions();
    } catch (error) {
      console.error("Error fetching Arabic verses:", error);
      new import_obsidian.Notice("Error fetching some Arabic verses");
    }
  }
  async fetchTranslationVersesForCurrentPage() {
    var _a;
    if (!this.plugin.settings.searchArabicEdition) {
      return;
    }
    try {
      const startIdx = (this.currentPage - 1) * this.resultsPerPage;
      const endIdx = Math.min(startIdx + this.resultsPerPage, this.searchResults.length);
      const currentPageResults = this.searchResults.slice(startIdx, endIdx);
      const unfetchedResults = currentPageResults.filter((match) => {
        const verseKey = `${match.surah.number}:${match.numberInSurah}`;
        return !this.fetchedTranslationVerses.has(verseKey);
      });
      if (unfetchedResults.length === 0) {
        return;
      }
      const edition = Translations[this.plugin.settings.translatorLanguage][this.plugin.settings.translatorIndex].identifier;
      const offlineMode = this.plugin.settings.offlineMode && ((_a = this.plugin.offlineData) == null ? void 0 : _a[edition]);
      if (offlineMode) {
        console.log("Offline mode enabled. Fetching translation verses for current page from local data...");
        unfetchedResults.forEach((match) => {
          var _a2, _b, _c, _d, _e, _f;
          const verseKey = `${match.surah.number}:${match.numberInSurah}`;
          const localVerse = (_f = (_e = (_d = (_c = (_b = (_a2 = this.plugin.offlineData) == null ? void 0 : _a2[edition]) == null ? void 0 : _b.data) == null ? void 0 : _c.surahs) == null ? void 0 : _d[match.surah.number - 1]) == null ? void 0 : _e.ayahs) == null ? void 0 : _f.find((verse) => verse.numberInSurah === match.numberInSurah);
          if (localVerse == null ? void 0 : localVerse.text) {
            match.arabicText = match.text;
            match.text = localVerse.text;
            this.fetchedTranslationVerses.add(verseKey);
          }
        });
        this.refreshSuggestions();
        return;
      }
      console.log("Online mode enabled. Fetching translation verses for current page by API...");
      const fetchPromises = unfetchedResults.map((match) => () => {
        const verseKey = `${match.surah.number}:${match.numberInSurah}`;
        return fetch(`http://api.alquran.cloud/v1/ayah/${match.surah.number}:${match.numberInSurah}/${edition}`).then((res) => res.json()).then((data) => ({ match, data, verseKey })).catch((error) => ({ match, error, verseKey }));
      });
      const results = await rateLimit(fetchPromises, 3, 1e3);
      results.forEach((result) => {
        var _a2;
        if (((_a2 = result.data) == null ? void 0 : _a2.code) === 200) {
          result.match.arabicText = result.match.text;
          result.match.text = result.data.data.text;
          this.fetchedTranslationVerses.add(result.verseKey);
        } else if (result.error) {
          console.error(`Error fetching translation verse for ${result.match.surah.number}:${result.match.numberInSurah}:`, result.error);
        }
      });
      this.refreshSuggestions();
    } catch (error) {
      console.error("Error fetching translation verses:", error);
      new import_obsidian.Notice("Error fetching some translation verses");
    }
  }
  getSuggestions(query) {
    if (!query) {
      this.searchResults = [];
      this.suggestions = [];
      this.fetchedArabicVerses.clear();
      this.fetchedTranslationVerses.clear();
      this.currentPage = 1;
      return [];
    }
    const startIdx = (this.currentPage - 1) * this.resultsPerPage;
    const endIdx = Math.min(startIdx + this.resultsPerPage, this.searchResults.length);
    return this.searchResults.slice(startIdx, endIdx);
  }
  renderSuggestion(match, el) {
    el.addClass("suggestion-item");
    const titleEl = el.createEl("div", { cls: "suggestion-title" });
    const surahEl = titleEl.createSpan({ cls: "surah-reference" });
    surahEl.setText(match.surah.englishName);
    const verseRef = titleEl.createSpan({ cls: "verse-reference" });
    verseRef.setText(` ${match.surah.number}:${match.numberInSurah}`);
    const textEl = el.createEl("div", { cls: "suggestion-text" });
    textEl.innerHTML = this.highlightSearchMatches(match.text, this.inputEl.value);
    if (match.arabicText) {
      const arabicEl = el.createEl("div", { cls: "quran-arabic" });
      arabicEl.style.marginTop = "10px";
      arabicEl.innerHTML = this.plugin.settings.searchArabicEdition ? this.highlightSearchMatches(match.arabicText, this.inputEl.value) : match.arabicText;
    }
    el.addEventListener("mouseover", () => {
      const items = this.resultContainerEl.querySelectorAll(".suggestion-item");
      const index = Array.from(items).indexOf(el);
      if (index >= 0) {
        this.setSelectedItem(index, true);
      }
    });
  }
  highlightSearchMatches(text, query) {
    if (!query)
      return text;
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const regex = new RegExp(`(${escapedQuery})`, "gi");
    return text.replace(regex, '<span style="color: #60a5fa; font-weight: bold;">$1</span>');
  }
  refreshSuggestions() {
    const query = this.inputEl.value.trim();
    if (!query) {
      this.searchResults = [];
      this.suggestions = [];
      this.fetchedArabicVerses.clear();
      this.fetchedTranslationVerses.clear();
      this.currentPage = 1;
      super.updateSuggestions();
      return;
    }
    this.suggestions = this.getSuggestions(query);
    super.updateSuggestions();
  }
  setSelectedItem(index, scrollIntoView = false) {
    const items = this.resultContainerEl.querySelectorAll(".suggestion-item");
    items.forEach((item) => item.classList.remove("is-selected"));
    if (index >= 0 && index < items.length) {
      const selectedItem = items[index];
      selectedItem.classList.add("is-selected");
      if (scrollIntoView) {
        selectedItem.scrollIntoView({ block: "nearest" });
      }
    }
  }
  async onChooseSuggestion(match, evt) {
    const verseRef = `${match.surah.number}:${match.numberInSurah}`;
    const verseContent = await this.plugin.getAyah(verseRef);
    this.editor.replaceSelection(verseContent);
  }
};
async function rateLimit(promises, batchSize = 3, delayMs = 500) {
  const results = [];
  for (let i = 0; i < promises.length; i += batchSize) {
    const batch = promises.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map((p) => p()));
    results.push(...batchResults);
    if (i + batchSize < promises.length) {
      await new Promise((resolve) => setTimeout(resolve, delayMs));
    }
  }
  return results;
}
var QuranLookupPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.offlineData = {};
    this.preprocessedArabicData = [];
    this.preprocessedTranslationData = [];
  }
  async onload() {
    await this.loadSettings();
    if (this.settings.offlineMode) {
      await this.ensureOfflineData();
    }
    this.addCommand({
      id: "ayah-list-command",
      name: "Retrieve Ayaat",
      editorCallback: async (editor, view) => {
        const ayaat = editor.getSelection().split(" ").filter(Boolean);
        let totalT = "";
        let verseText = "";
        for (const verse of ayaat) {
          let rVerse = verse;
          const surah = verse.split(":")[0];
          if (isNaN(parseInt(surah))) {
            let surahIndex = 0;
            if (!this.fuse) {
              await this.initializeSurahData();
              console.error("Initializing Surah data...");
            }
            const surahNum = this.fuse.search(surah)[0].item;
            if (surahNum != void 0) {
              surahIndex = parseInt(surahNum.index);
            }
            rVerse = "" + surahIndex + ":" + verse.split(":")[1];
          }
          if (rVerse.includes("-")) {
            verseText = await this.getAyahRange(rVerse);
          } else {
            verseText = await this.getAyah(rVerse) + "\n";
          }
          totalT += verseText + "\n";
        }
        editor.replaceSelection(totalT);
      }
    });
    this.addCommand({
      id: "search-quran",
      name: "Search Quran",
      editorCallback: (editor, view) => {
        new QuranSearchModal(this.app, this, editor).open();
      }
    });
    this.addSettingTab(new QuranLookupSettingTab(this.app, this));
    this.updateStyles();
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async onLayoutReady() {
    console.log("Layout is ready. Initializing Surah data...");
    await this.initializeSurahData();
  }
  async initializeSurahData() {
    var _a, _b;
    try {
      (_a = this.surahJson) != null ? _a : this.surahJson = require_surahSlim();
      (_b = this.surahList) != null ? _b : this.surahList = this.surahJson.map((m) => m.title);
      const options = { keys: ["title"] };
      this.fuse = new Fuse(this.surahJson, options);
      console.log("Surah data initialized successfully.");
    } catch (error) {
      console.error("Failed to initialize Surah data:", error);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  handleParens(txtVal, removeParens) {
    return removeParens ? txtVal.replace(/ *\([^)]*\)*/g, "").replace(/ \[(.+?)\]/g, " ").replace(/\s+([.,!":])/g, "$1") : txtVal;
  }
  updateStyles() {
    const sheets = Array.from(document.styleSheets);
    for (const sheet of sheets) {
      try {
        const rules = sheet.cssRules || sheet.rules;
        for (const rule of Array.from(rules)) {
          if (rule.selectorText === ".quran-arabic") {
            rule.style.fontFamily = `${this.settings.fontFamily}, 'Segoe UI Fixed', monospace`;
            rule.style.fontSize = this.settings.fontSize;
          }
        }
      } catch (e) {
        console.warn("Could not access stylesheet:", e);
      }
    }
    if (this.settings.arabicStyleIndex == 2) {
      this.toggleCodeStyling(true);
    } else {
      this.toggleCodeStyling(false);
    }
  }
  toggleCodeStyling(apply) {
    const styleId = "quran-arabic-code-style";
    const existingStyle = document.getElementById(styleId);
    if (existingStyle) {
      existingStyle.remove();
    }
    if (apply) {
      const style = document.createElement("style");
      style.id = styleId;
      style.textContent = `
            .cm-s-obsidian span.cm-inline-code,
            .cm-s-obsidian .HyperMD-codeblock,
            .markdown-preview-view code,
            .callout-content code,
            .markdown-rendered code,
            .table-cell-wrapper .esm-rtl,
            td.esm-rtl {
                background-color: transparent !important;
                font-family: ${this.settings.fontFamily}, 'Segoe UI Fixed', monospace;
                font-size: ${this.settings.fontSize} !important;
                line-height: 200%;
                direction: rtl;
            }
        `;
      document.head.appendChild(style);
    }
  }
  applyArabicStyle(txtVal, styleIndex) {
    if (styleIndex == 1) {
      return `<span class="quran-arabic">${txtVal}</span>`;
    } else if (styleIndex == 2) {
      return "`" + txtVal + "`";
    } else {
      return txtVal;
    }
  }
  resolveAPIurl(surah, edition, startAyah, ayahRange = 1) {
    return "https://api.alquran.cloud/v1/surah/" + surah + "/" + edition + "?offset=" + startAyah + "&limit=" + ayahRange;
  }
  async fetchArabicOnly(urlArabic) {
    const arabicResponse = await fetch(urlArabic);
    const arabic = await arabicResponse.json();
    return arabic;
  }
  async fetchArabicAndTranslation(urlArabic, urlEnglish) {
    const [arabicResponse, englishResponse] = await Promise.all([
      fetch(urlArabic),
      fetch(urlEnglish)
    ]);
    const arabic = await arabicResponse.json();
    const english = await englishResponse.json();
    return [arabic, english];
  }
  async getAyah(verse) {
    const surah = verse.split(":")[0];
    const ayah = parseInt(verse.split(":")[1]) - 1;
    let result = "";
    if (this.settings.offlineMode) {
      const arabicData = await this.getOfflineVerse(parseInt(surah), ayah + 1, "ar.quran-simple");
      let translationData = null;
      if (this.settings.includeTranslation) {
        const translationEdition = Translations[this.settings.translatorLanguage][this.settings.translatorIndex].identifier;
        translationData = await this.getOfflineVerse(parseInt(surah), ayah + 1, translationEdition);
      }
      if (arabicData) {
        const arText = this.applyArabicStyle(arabicData.data.ayahs[0].text, this.settings.arabicStyleIndex);
        const surahName = translationData ? translationData.data.englishName : arabicData.data.name;
        const surahNumber = arabicData.data.number;
        const ayahNumber = arabicData.data.ayahs[0].numberInSurah;
        const verseHeader = `${surahName} (${surahNumber}:${ayahNumber})`;
        if (this.settings.displayTypeIndex === 1) {
          result += `| ${verseHeader} |  |
| ---- | ---- |
`;
          if (translationData) {
            const enText = this.handleParens(translationData.data.ayahs[0].text, this.settings.removeParens);
            result += "| " + enText + " | " + arText + " |\n";
          } else {
            result += "| " + arText + " | " + arText + " |\n";
          }
        } else if (this.settings.displayTypeIndex === 2) {
          const calloutType = this.settings.calloutType || "tip";
          result += "> [!" + calloutType + "]+ " + verseHeader + "\n";
          if (translationData) {
            const enText = this.handleParens(translationData.data.ayahs[0].text, this.settings.removeParens);
            result += "> " + enText + "\n> " + arText + "\n>";
          } else {
            result += "> " + arText + "\n>";
          }
        } else {
          result += `${verseHeader}
`;
          if (translationData) {
            const enText = this.handleParens(translationData.data.ayahs[0].text, this.settings.removeParens);
            result += `${enText}
${arText}
`;
          } else {
            result += arText + "\n";
          }
        }
      }
    } else {
      const urlArabic = this.resolveAPIurl(surah, "ar.quran-simple", ayah);
      if (this.settings.includeTranslation) {
        const translator = Translations[this.settings.translatorLanguage][this.settings.translatorIndex].identifier;
        const urlEnglish = this.resolveAPIurl(surah, translator, ayah);
        const [arabic, english] = await this.fetchArabicAndTranslation(urlArabic, urlEnglish);
        const arText = this.applyArabicStyle(arabic.data.ayahs[0].text, this.settings.arabicStyleIndex);
        const enText = this.handleParens(english.data.ayahs[0].text, this.settings.removeParens);
        const surahName = english.data.englishName;
        const surahNumber = english.data.number;
        const ayahNumber = english.data.ayahs[0].numberInSurah;
        const verseHeader = `${surahName} (${surahNumber}:${ayahNumber})`;
        if (this.settings.displayTypeIndex === 1) {
          result += `| ${verseHeader} |  |
| ---- | ---- |
`;
          result += "| " + enText + " | " + arText + " |\n";
        } else if (this.settings.displayTypeIndex === 2) {
          const calloutType = this.settings.calloutType || "tip";
          result += "> [!" + calloutType + "]+ " + verseHeader + "\n> " + enText + "\n> " + arText + "\n>";
        } else {
          result += `${verseHeader}
${enText}
` + arText + "\n";
        }
      } else {
        const arabic = await this.fetchArabicOnly(urlArabic);
        const arText = this.applyArabicStyle(arabic.data.ayahs[0].text, this.settings.arabicStyleIndex);
        const surahName = arabic.data.name;
        const surahNumber = arabic.data.number;
        const ayahNumber = arabic.data.ayahs[0].numberInSurah;
        const verseHeader = `${surahName} (${surahNumber}:${ayahNumber})`;
        if (this.settings.displayTypeIndex === 1) {
          result += `| ${verseHeader} |
| ---- |
`;
          result += "| " + arText + " |\n";
        } else if (this.settings.displayTypeIndex === 2) {
          const calloutType = this.settings.calloutType || "tip";
          result += `> [!${calloutType}]+ ${verseHeader}
> ` + arText + "\n>";
        } else {
          result += `${verseHeader}
` + arText + "\n";
        }
      }
    }
    return result;
  }
  async getAyahRange(verse) {
    const surah = verse.split(":")[0];
    const ayahRangeText = verse.split(":")[1];
    const startAyah = parseInt(ayahRangeText.split("-")[0]) - 1;
    const endAyah = parseInt(ayahRangeText.split("-")[1]);
    const ayahRange = endAyah - startAyah;
    let result = "";
    if (this.settings.offlineMode) {
      const arabicData = await this.getOfflineVerseRange(parseInt(surah), startAyah + 1, endAyah, "ar.quran-simple");
      let translationData = null;
      if (this.settings.includeTranslation) {
        const translationEdition = Translations[this.settings.translatorLanguage][this.settings.translatorIndex].identifier;
        translationData = await this.getOfflineVerseRange(parseInt(surah), startAyah + 1, endAyah, translationEdition);
      }
      if (arabicData) {
        const surahName = translationData ? translationData.data.englishName : arabicData.data.name;
        const surahNumber = arabicData.data.number;
        const verseHeader = `${surahName} (${surahNumber}:${ayahRangeText})`;
        if (this.settings.displayTypeIndex === 1) {
          result += `| ${verseHeader} |  |
| ---- | ---- |
`;
          for (let i = 0; i < arabicData.data.ayahs.length; i++) {
            const arText = this.applyArabicStyle(arabicData.data.ayahs[i].text, this.settings.arabicStyleIndex);
            if (translationData) {
              const enText = this.handleParens(translationData.data.ayahs[i].text, this.settings.removeParens);
              result += "| " + enText + " | " + arText + " |\n";
            } else {
              result += "| " + arText + " | " + arText + " |\n";
            }
          }
        } else if (this.settings.displayTypeIndex === 2) {
          const calloutType = this.settings.calloutType || "tip";
          result += `> [!${calloutType}]+ ${verseHeader}
`;
          for (let i = 0; i < arabicData.data.ayahs.length; i++) {
            const arText = this.applyArabicStyle(arabicData.data.ayahs[i].text, this.settings.arabicStyleIndex);
            if (translationData) {
              const enText = this.handleParens(translationData.data.ayahs[i].text, this.settings.removeParens);
              result += "> " + enText + "\n> " + arText + "\n>\n";
            } else {
              result += "> " + arText + "\n>\n";
            }
          }
          result = result.trim();
        } else {
          result += `${verseHeader}
`;
          for (let i = 0; i < arabicData.data.ayahs.length; i++) {
            const arText = this.applyArabicStyle(arabicData.data.ayahs[i].text, this.settings.arabicStyleIndex);
            if (translationData) {
              const enText = this.handleParens(translationData.data.ayahs[i].text, this.settings.removeParens);
              result += `${enText}
${arText}

`;
            } else {
              result += arText + "\n\n";
            }
          }
          result = result.trim();
        }
      }
    } else {
      const urlArabic = this.resolveAPIurl(surah, "ar.quran-simple", startAyah, ayahRange);
      if (this.settings.includeTranslation) {
        const translator = Translations[this.settings.translatorLanguage][this.settings.translatorIndex].identifier;
        const urlEnglish = this.resolveAPIurl(surah, translator, startAyah, ayahRange);
        const [arabic, english] = await this.fetchArabicAndTranslation(urlArabic, urlEnglish);
        const surahName = english.data.englishName;
        const surahNumber = english.data.number;
        const verseHeader = `${surahName} (${surahNumber}:${ayahRangeText})`;
        if (this.settings.displayTypeIndex === 1) {
          result += `| ${verseHeader} |  |
| ---- | ---- |
`;
          for (let i = 0; i < arabic.data.ayahs.length; i++) {
            const arText = this.applyArabicStyle(arabic.data.ayahs[i].text, this.settings.arabicStyleIndex);
            const enText = this.handleParens(english.data.ayahs[i].text, this.settings.removeParens);
            result += "| " + enText + " | " + arText + " |\n";
          }
        } else if (this.settings.displayTypeIndex === 2) {
          const calloutType = this.settings.calloutType || "tip";
          result += `> [!${calloutType}]+ ${verseHeader}
`;
          for (let i = 0; i < arabic.data.ayahs.length; i++) {
            const arText = this.applyArabicStyle(arabic.data.ayahs[i].text, this.settings.arabicStyleIndex);
            const enText = this.handleParens(english.data.ayahs[i].text, this.settings.removeParens);
            result += `> ${enText}
> ` + arText + "\n>\n";
          }
          result = result.trim();
        } else {
          result += `${verseHeader}
`;
          for (let i = 0; i < arabic.data.ayahs.length; i++) {
            const arText = this.applyArabicStyle(arabic.data.ayahs[i].text, this.settings.arabicStyleIndex);
            const enText = this.handleParens(english.data.ayahs[i].text, this.settings.removeParens);
            result += `${enText}
` + arText + "\n\n";
          }
          result = result.trim();
        }
      } else {
        const arabic = await this.fetchArabicOnly(urlArabic);
        const surahName = arabic.data.name;
        const surahNumber = arabic.data.number;
        const verseHeader = `${surahName} (${surahNumber}:${ayahRangeText})`;
        if (this.settings.displayTypeIndex === 1) {
          result += `| ${verseHeader} |
| ---- |
`;
          for (let i = 0; i < arabic.data.ayahs.length; i++) {
            const arText = arabic.data.ayahs[i].text;
            result += "| " + arText + " |\n";
          }
        } else if (this.settings.displayTypeIndex === 2) {
          const calloutType = this.settings.calloutType || "tip";
          result += `> [!${calloutType}]+ ${verseHeader}
`;
          for (let i = 0; i < arabic.data.ayahs.length; i++) {
            const arText = arabic.data.ayahs[i].text;
            result += "> " + arText + "\n>\n";
          }
          result = result.trim();
        } else {
          result += `${verseHeader}
`;
          for (let i = 0; i < arabic.data.ayahs.length; i++) {
            const arText = arabic.data.ayahs[i].text;
            result += arText + "\n\n";
          }
          result = result.trim();
        }
      }
    }
    return result;
  }
  async fetchWithRetry(url, retries = 3) {
    for (let i = 0; i < retries; i++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3e4);
        const response = await fetch(url, {
          signal: controller.signal,
          headers: {
            "Accept": "application/json"
          }
        });
        clearTimeout(timeoutId);
        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);
        return response;
      } catch (error) {
        if (error.name === "AbortError") {
          console.log("Request timed out");
        }
        if (i === retries - 1)
          throw error;
        await new Promise((resolve) => setTimeout(resolve, 1e3 * (i + 1)));
      }
    }
    throw new Error("Failed to fetch after maximum retries");
  }
  async ensureOfflineData() {
    const arabicEdition = "ar.quran-simple";
    const translationEdition = this.settings.includeTranslation ? Translations[this.settings.translatorLanguage][this.settings.translatorIndex].identifier : null;
    try {
      const storage = await this.loadData();
      if (!storage) {
        await this.saveData({ translations: {} });
      }
      const arabicData = await this.loadFromOfflineStorage(arabicEdition);
      const translationData = translationEdition ? await this.loadFromOfflineStorage(translationEdition) : null;
      if (!arabicData) {
        await this.retrieveFullEditionByAPI(arabicEdition);
      } else {
        this.offlineData[arabicEdition] = arabicData;
      }
      if (translationEdition && !translationData) {
        await this.retrieveFullEditionByAPI(translationEdition);
      } else if (translationEdition && translationData) {
        this.offlineData[translationEdition] = translationData;
      }
    } catch (error) {
      console.error("Failed to ensure offline data:", error);
      throw error;
    }
    if (this.offlineData[arabicEdition]) {
      this.preprocessedArabicData = this.preprocessArabicData(this.offlineData[arabicEdition]);
    }
    if (this.settings.includeTranslation && translationEdition != null) {
      if (this.offlineData[translationEdition]) {
        this.preprocessedTranslationData = this.preprocessTranslationData(this.offlineData[translationEdition]);
      }
    }
  }
  async retrieveFullEditionByAPI(quranEdition) {
    console.log(`Downloading translation data (${quranEdition})...`);
    const fetchResponse = await this.fetchWithRetry(`https://api.alquran.cloud/v1/quran/${quranEdition}`);
    const responseJson = await fetchResponse.json();
    if (!responseJson.data) {
      throw new Error("Invalid data received from API");
    }
    await this.saveOfflineData(quranEdition, responseJson);
  }
  async loadFromOfflineStorage(edition) {
    var _a;
    try {
      const data = await this.loadData();
      if (!data || typeof data !== "object") {
        await this.saveData({ translations: {} });
        return null;
      }
      const storage = data;
      return ((_a = storage.translations) == null ? void 0 : _a[edition]) || null;
    } catch (error) {
      console.error(`Failed to load offline data for ${edition}:`, error);
      return null;
    }
  }
  async saveOfflineData(edition, data) {
    try {
      const storage = await this.loadData() || { translations: {} };
      storage.translations = storage.translations || {};
      storage.translations[edition] = data;
      await this.saveData(storage);
      this.offlineData[edition] = data;
    } catch (error) {
      console.error(`Failed to save offline data for ${edition}:`, error);
      throw error;
    }
  }
  async getOfflineVerse(surah, ayah, edition) {
    const data = this.offlineData[edition];
    if (!data) {
      new import_obsidian.Notice(`No offline data available for edition ${edition}`);
      throw new Error(`No offline data available for edition ${edition}`);
    }
    const surahData = data.data.surahs.find((s) => s.number === surah);
    if (!surahData) {
      new import_obsidian.Notice(`Surah ${surah} not found. Only ${data.data.surahs.length} surahs exist`);
      throw new Error(`Surah ${surah} not found in offline data`);
    }
    const ayahData = surahData.ayahs.find((a) => a.numberInSurah === ayah);
    if (!ayahData) {
      new import_obsidian.Notice(`Ayah ${ayah} in Surah ${surah} not found. Only ${surahData.ayahs.length} ayahs exist`);
      throw new Error(`Ayah ${ayah} not found in Surah ${surah}`);
    }
    return {
      data: {
        number: surahData.number,
        name: surahData.name,
        englishName: surahData.englishName,
        ayahs: [ayahData]
      }
    };
  }
  async getOfflineVerseRange(surah, startAyah, endAyah, edition) {
    const data = this.offlineData[edition];
    if (!data) {
      throw new Error(`No offline data available for edition ${edition}`);
    }
    const surahData = data.data.surahs.find((s) => s.number === surah);
    if (!surahData) {
      throw new Error(`Surah ${surah} not found in offline data`);
    }
    const ayahs = surahData.ayahs.filter((a) => a.numberInSurah >= startAyah && a.numberInSurah <= endAyah);
    if (ayahs.length === 0) {
      throw new Error(`No ayahs found in range ${startAyah}-${endAyah} for Surah ${surah}`);
    }
    return {
      data: {
        number: surahData.number,
        name: surahData.name,
        englishName: surahData.englishName,
        ayahs
      }
    };
  }
  async toggleOfflineMode(value) {
    if (value) {
      new import_obsidian.Notice("Downloading Quran data for offline use...");
      try {
        await this.ensureOfflineData();
        this.settings.offlineMode = true;
        await this.saveSettings();
        new import_obsidian.Notice("Offline mode enabled successfully");
      } catch (error) {
        console.error("Failed to enable offline mode:", error);
        new import_obsidian.Notice("Failed to enable offline mode. Please check your internet connection and try again.");
        this.settings.offlineMode = false;
        await this.saveSettings();
      }
    } else {
      this.settings.offlineMode = false;
      await this.saveSettings();
      new import_obsidian.Notice("Offline mode disabled");
    }
  }
  removeTashkeel(text) {
    const tashkeelRegex = /[\u0617-\u061A\u064B-\u0652]/g;
    return text.replace(tashkeelRegex, "");
  }
  normalizeArabic(text) {
    return text.replace(/[أإآا]/g, "\u0627").replace(/ى/g, "\u064A").replace(/ة/g, "\u0647").replace(/ـ/g, "");
  }
  preprocessArabicData(quranData) {
    return quranData.data.surahs.flatMap((surah) => surah.ayahs.map((ayah) => ({
      number: ayah.number,
      text: ayah.text,
      originalText: ayah.text,
      numberInSurah: ayah.numberInSurah,
      surahNumber: surah.number,
      surahName: surah.name,
      normalizedText: this.normalizeArabic(ayah.text),
      textWithoutTashkeel: this.removeTashkeel(this.normalizeArabic(ayah.text))
    })));
  }
  async searchOfflineArabic(query, limit = 3e3) {
    if (!this.offlineData["ar.quran-simple"]) {
      throw new Error("Arabic edition not available offline");
    }
    const originalQuery = this.normalizeArabic(query);
    const queryWithoutTashkeel = this.removeTashkeel(originalQuery);
    if (this.preprocessedArabicData.length === 0) {
      this.preprocessedArabicData = this.preprocessArabicData(this.offlineData["ar.quran-simple"]);
    }
    const options = {
      keys: ["normalizedText", "textWithoutTashkeel"],
      includeScore: true,
      threshold: 0,
      distance: 0,
      minMatchCharLength: 1,
      findAllMatches: true,
      ignoreLocation: true,
      weights: {
        normalizedText: 2,
        textWithoutTashkeel: 1
      }
    };
    const offlineFuse = new Fuse(this.preprocessedArabicData, options);
    const results = offlineFuse.search({
      $or: [
        { normalizedText: originalQuery },
        { textWithoutTashkeel: queryWithoutTashkeel }
      ]
    });
    return results.slice(0, limit).map((result) => ({
      number: result.item.number,
      text: result.item.text,
      numberInSurah: result.item.numberInSurah,
      surah: {
        number: result.item.surahNumber,
        name: result.item.surahName,
        englishName: result.item.surahName,
        englishNameTranslation: result.item.surahName,
        revelationType: "Meccan"
      },
      edition: {
        identifier: "ar.quran-simple",
        language: "ar",
        name: "Simple Arabic",
        englishName: "Simple Arabic",
        type: "quran"
      }
    }));
  }
  preprocessTranslationData(translationData) {
    return translationData.data.surahs.flatMap((surah) => surah.ayahs.map((ayah) => ({
      number: ayah.number,
      text: ayah.text,
      originalText: ayah.text,
      numberInSurah: ayah.numberInSurah,
      surahNumber: surah.number,
      surahName: surah.name,
      surahEnglishName: surah.englishName
    })));
  }
  async searchOfflineTranslation(query, limit = 3e3) {
    const translationEdition = Translations[this.settings.translatorLanguage][this.settings.translatorIndex].identifier;
    if (!this.offlineData[translationEdition]) {
      throw new Error(`Translation edition ${translationEdition} not available offline`);
    }
    if (this.preprocessedTranslationData.length === 0) {
      this.preprocessedTranslationData = this.preprocessTranslationData(this.offlineData[translationEdition]);
    }
    const options = {
      includeScore: true,
      keys: ["text"],
      threshold: 0.1,
      ignoreLocation: true,
      minMatchCharLength: 3,
      useExtendedSearch: true
    };
    const offlineFuse = new Fuse(this.preprocessedTranslationData, options);
    const results = offlineFuse.search(query);
    return results.filter((result) => result.score && result.score < 0.99).slice(0, limit).map((result) => ({
      number: result.item.number,
      text: result.item.text,
      numberInSurah: result.item.numberInSurah,
      surah: {
        number: result.item.surahNumber,
        name: result.item.surahName,
        englishName: result.item.surahEnglishName,
        englishNameTranslation: result.item.surahName,
        revelationType: "Meccan"
      },
      edition: {
        identifier: translationEdition,
        language: this.settings.translatorLanguage,
        name: Translations[this.settings.translatorLanguage][this.settings.translatorIndex].name,
        englishName: Translations[this.settings.translatorLanguage][this.settings.translatorIndex].name,
        type: "translation"
      }
    }));
  }
};
var QuranLookupSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    var _a, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Quran Lookup Settings" });
    new import_obsidian.Setting(containerEl).setName("Include Translation").setDesc("If true, provides translation under the Arabic verse").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.includeTranslation).onChange(async (includeTranslation) => {
        this.plugin.settings.includeTranslation = includeTranslation;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.includeTranslation) {
      new import_obsidian.Setting(containerEl).setName("Translator Language").setDesc("Select the language for translation").addDropdown((dropdown) => {
        const languages = Object.keys(Translations);
        languages.forEach((lang) => {
          dropdown.addOption(lang, lang.toUpperCase());
        });
        dropdown.setValue(this.plugin.settings.translatorLanguage).onChange(async (value) => {
          this.plugin.settings.translatorLanguage = value;
          this.plugin.settings.translatorIndex = 0;
          await this.plugin.saveSettings();
          this.display();
        });
      });
      new import_obsidian.Setting(containerEl).setName("Translation Type").setDesc("Which translation to use").addDropdown((dropdown) => {
        const selectedLanguage = this.plugin.settings.translatorLanguage;
        const translations = Translations[selectedLanguage];
        translations.forEach((translation, index) => {
          dropdown.addOption(index.toString(), translation.name);
        });
        dropdown.setValue(this.plugin.settings.translatorIndex.toString()).onChange(async (value) => {
          this.plugin.settings.translatorIndex = +value;
          await this.plugin.saveSettings();
          if (this.plugin.settings.offlineMode && this.plugin.settings.includeTranslation) {
            const translationEdition = Translations[this.plugin.settings.translatorLanguage][+value].identifier;
            const existingData = await this.plugin.loadFromOfflineStorage(translationEdition);
            if (!existingData) {
              new import_obsidian.Notice("Downloading new translation for offline use...");
              try {
                const response = await this.plugin.fetchWithRetry(`https://api.alquran.cloud/v1/quran/${translationEdition}`);
                const translationJson = await response.json();
                if (!translationJson.data) {
                  throw new Error("Invalid translation data received from API");
                }
                await this.plugin.saveOfflineData(translationEdition, translationJson);
                new import_obsidian.Notice("New translation downloaded successfully");
              } catch (error) {
                console.error("Failed to download translation:", error);
                new import_obsidian.Notice("Failed to download translation. Please check your internet connection.");
              }
            }
          }
          this.display();
        });
      });
      new import_obsidian.Setting(containerEl).setName("Remove Parenthesis Content").setDesc("If true, removes the added translator content that would normally appear in parenthesis").addToggle((toggle) => {
        toggle.setValue(this.plugin.settings.removeParens).onChange(async (removeParens) => {
          this.plugin.settings.removeParens = removeParens;
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName("Arabic Styling Options").setDesc("Wraps the Arabic verse in HTML Span CSS, backticks, or None").addDropdown((dropdown) => {
      dropdown.addOptions(ArabicStyleOptions).setValue(this.plugin.settings.arabicStyleIndex.toString()).onChange(async (value) => {
        this.plugin.settings.arabicStyleIndex = +value;
        if (this.plugin.settings.arabicStyleIndex == 2) {
          this.plugin.toggleCodeStyling(true);
        } else {
          this.plugin.toggleCodeStyling(false);
        }
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Font Family").setDesc("Select the font family for the Quran text.").addDropdown((dropdown) => {
      dropdown.addOptions({
        "me_quran": "me_quran",
        "NooreHidayah": "NooreHidayah",
        "Uthmani": "Uthmani",
        "Amiri": "Amiri",
        "Quran": "Quran",
        "kfc_naskh": "kfc_naskh",
        "scheherazade": "scheherazade",
        "Kitab-Regular": "Kitab-Regular",
        "pdms_saleem": "pdms_saleem",
        "xb_zar-webfont": "xb_zar-webfont"
      }).setValue(this.plugin.settings.fontFamily).onChange(async (value) => {
        this.plugin.settings.fontFamily = value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Font Size").setDesc("Set the font size for the Quran text.").then((setting) => {
      const container = setting.controlEl.createDiv({ cls: "font-size-container" });
      const textField = container.createEl("input", { type: "text" });
      textField.value = this.plugin.settings.fontSize;
      textField.addEventListener("input", async (event) => {
        this.plugin.settings.fontSize = textField.value;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
      });
      const plusButton = container.createEl("button", { text: "+" });
      plusButton.addEventListener("click", async () => {
        let fontSize = parseInt(this.plugin.settings.fontSize.replace("px", ""), 10);
        fontSize = isNaN(fontSize) ? 24 : fontSize;
        fontSize += 2;
        this.plugin.settings.fontSize = `${fontSize}px`;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
        textField.value = this.plugin.settings.fontSize;
      });
      const minusButton = container.createEl("button", { text: "-" });
      minusButton.addEventListener("click", async () => {
        let fontSize = parseInt(this.plugin.settings.fontSize.replace("px", ""), 10);
        fontSize = isNaN(fontSize) ? 24 : fontSize;
        fontSize = Math.max(2, fontSize - 2);
        this.plugin.settings.fontSize = `${fontSize}px`;
        await this.plugin.saveSettings();
        this.plugin.updateStyles();
        textField.value = this.plugin.settings.fontSize;
      });
    });
    new import_obsidian.Setting(containerEl).setName("Display Container Type").setDesc("Which container to use for displaying the verses").addDropdown((dropdown) => {
      dropdown.addOptions(DisplayOptions).setValue(this.plugin.settings.displayTypeIndex.toString()).onChange(async (value) => {
        this.plugin.settings.displayTypeIndex = +value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (this.plugin.settings.displayTypeIndex === 2) {
      new import_obsidian.Setting(containerEl).setName("Callout Type").setDesc("Select the callout type to use").addDropdown((dropdown) => {
        const calloutTypes = {
          "note": "Note",
          "abstract": "Abstract",
          "info": "Info",
          "todo": "Todo",
          "tip": "Tip",
          "success": "Success",
          "question": "Question",
          "warning": "Warning",
          "failure": "Failure",
          "danger": "Danger",
          "bug": "Bug",
          "example": "Example",
          "quote": "Quote"
        };
        dropdown.addOptions(calloutTypes).setValue(this.plugin.settings.calloutType || "tip").onChange(async (value) => {
          this.plugin.settings.calloutType = value;
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    this.addPreview(containerEl);
    new import_obsidian.Setting(containerEl).setName("Offline Mode").setDesc("If true, uses offline data for Quran verses").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.offlineMode).onChange(async (value) => {
        await this.plugin.toggleOfflineMode(value);
        this.display();
      });
    });
    if (this.plugin.settings.offlineMode) {
      const downloadedEditionsEl = containerEl.createEl("div", {
        cls: "setting-item-description",
        attr: { style: "margin-left: 40px; margin-bottom: 24px;" }
      });
      const downloadedEditions = Object.keys(this.plugin.offlineData || {});
      if (downloadedEditions.length > 0) {
        downloadedEditionsEl.createEl("div", {
          text: "Downloaded editions:",
          attr: { style: "margin-bottom: 8px; opacity: 0.75;" }
        });
        for (const edition of downloadedEditions) {
          const editionName = edition === "ar.quran-simple" ? "Arabic (Simple)" : ((_b = (_a = Translations[edition.split(".")[0]]) == null ? void 0 : _a.find((t) => t.identifier === edition)) == null ? void 0 : _b.name) || edition;
          downloadedEditionsEl.createEl("div", {
            text: `\u2022 ${editionName}`,
            attr: { style: "margin-left: 12px; opacity: 0.75;" }
          });
        }
      } else {
        downloadedEditionsEl.createEl("div", {
          text: "No editions downloaded yet. They will be downloaded automatically when verses are looked up.",
          attr: { style: "opacity: 0.75;" }
        });
      }
    }
  }
  async addPreview(containerEl) {
    const previewContainer = containerEl.createEl("div", { cls: "quran-lookup-preview" });
    previewContainer.createEl("h3", { text: "Preview" });
    let previewContent = "";
    try {
      const verse = "2:2";
      previewContent = await this.plugin.getAyah(verse);
    } catch (error) {
      console.error("Error fetching preview verse:", error);
      previewContent = "Unable to load preview. Please check your settings.";
    }
    previewContainer.empty();
    const markdownContainer = previewContainer.createEl("div", {
      cls: "markdown-preview-view",
      attr: {
        style: "pointer-events: none;"
      }
    });
    markdownContainer.classList.add("cm-embed-block", "cm-table-widget", "markdown-rendered");
    import_obsidian.MarkdownRenderer.renderMarkdown(previewContent, markdownContainer, "", this.plugin);
    const style = document.createElement("style");
    style.textContent = `
      .quran-lookup-preview table {
        border-collapse: collapse;
        width: 100%;
      }
      .quran-lookup-preview th,
      .quran-lookup-preview td {
        border: 1px solid transparent; /* Set the border color to transparent */
        padding: 8px;
        text-align: left;
      }
      .quran-lookup-preview .table-wrapper {
        overflow-x: auto;
      }
      .quran-lookup-preview .table-editor {
        border: 1px solid transparent; /* Set default border color to transparent */
      }
    `;
    document.head.appendChild(style);
  }
};

/* nosourcemap */